#函数的扩展

##函数参数的默认值
  * ES6前，不能直接为函数的参数指定默认值，只能变通 eg：y = y || 'default'
  * ES6允许为函数的参数设置默认值，即直接写在参数定义的后面
    参数变量是默认声明的，所以不能再用var、let、const来进行声明
  * 可以与解构赋值默认值结合使用
    使用对象的解构赋值默认值时，只有当函数的参数也是一个对象时，变量才会通过解构赋值而生成
  * 有默认值的参数不是尾参数，其实无法省略该参数，而不省略它后面的参数，除非显式的输入undefined
    传入undefined将触发该参数等于默认值，null则没有这个效果
  * 指定默认值后，函数的length属性将返回没有指定默认值参数个数
    如果设置的默认值的参数不是尾参数，那么length属性也不在计入后面的参数
  * 利用参数默认值，可以指定某个参数不得省略，如果省略就抛出一个错误
  * 另外可以将参数默认值设为undefined，表明这个参数是可以省略的

##rest参数
  * ES6引入rest参数(形式为"...变量名"),用于获取函数的多余参数,这样就不需要使用arguments对象了
  * rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量
  * 注意,rest参数之后不能再有其他参数(即只能是最后一个参数),否则会报错
  * 函数的length属性，不包括rest参数

##扩展运算符
  * 扩展运算符是三个点(...),好比rest参数的逆运算,将一个数组转为用逗号分隔的参数序列
  * 主要用于函数调用,扩展运算符与正常的函数参数可以结合使用，非常灵活
    eg：f(-1, ...args, 2, ...[3])
  * 替换数组的apply方法：不在需要apply方法,将数组转为函数的参数了
    ES5写法：var args = [0, 1, 2]; f.apply(null, args);
    ES6写法: var args = [0, 1, 2]; f(...args);
    将一个数组添加到另一个数组的尾部
    ES5写法：Array.prototype.push.apply(arrr1, arr2);
    ES6写法：arr1.push(...arr2);
  * 扩展运算符的应用:
    合并数组: ES5 arr1.concat(arr2, arr3); ES6 [...arr1, ...arr2, ...arr3]
    与解构赋值结合: const [first, ...rest] = [1, 2, 3, 4]; //first = 1; rest = [2, 3, 4];
                    如果将扩展运算符用于数组赋值,只能放在参数的最后一位，否则报错
    函数的返回值: JavaScript函数只能返回一个值，如果需要返回多个值，只能返回数组或对象
                  扩展运算符提供解决方法
    字符串: 扩展运算符可以将字符串转为真正的数组
            能够正确识别32位的Unicode字符，正确返回字符串长度的函数: return [...str].length
    实现了Iterator接口的对象: 
        可用扩展运算符将任何Iterator接口对象转为真正的数组,类数组对象可用Array.from方法将其转为真正的数组
    Map和Set结构,Generator函数
        扩展运算符内部调用的是数据结构的Iterator接口，所有具有Iterator接口的对象都可以使用扩展运算符
  * name属性
    返回函数的函数名，该属性早被浏览器广泛支持，直到ES6才写入标准
    将匿名函数赋值给一个变量，ES5的name属性返回空字符串，ES6返回实际的函数名
    具名函数赋值给一个变量，ES5、ES6都返回该函数原本的名字
    Function构造函数返回的实例，name属性的值为"anonymous"

##箭头函数
  * ES6允许使用"箭头"(=>)定义函数
    var f = v => v; 等同于:
    var f = function(v) {
      return v;
    }
    如果箭头函数不需要参数或需要多个参数，就使用圆括号代表参数部分
  * 简化回调函数
    [1, 2, 3].map(function (x) {
      return x*x;
    }); //普通写法
    [1, 2, 3].map(x => x*x); //箭头函数写法
  * 注意点
    函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象
    不可以当做构造函数，也就是说，不可以使用new命令
    不可以使用arguments对象，该对象再函数体内不存在，要用就用REST参数代替
    不可以使用yield命令，因此箭头函数不能用作Generator函数

##函数绑定
  * 箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法(call、apply、bind)
  * 该语法还是ES7的一个提案，但Babel转码器已经支持
    foo::bar 等同于 bar.bind(foo)
    foo::bar(...arguments) 等同于  bar.apply(foo, arguments)

##尾调用优化
  * 尾调用就是指某个函数的最后一步是调用另一个函数
  * 尾调用不一定出现在函数尾部，只要是最后一步操作即可
  * 尾调用优化：即只保留内层函数的调用帧
  * 函数调用自身，称为递归，如果尾调用自身，就称为尾递归
    递归非常耗内存，因为需要同时保存成千上百个调用帧，很容易发生"栈溢出"错误，
    但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生"栈溢出"错误
  

##函数参数的尾逗号
  * 允许函数的最后一个参数有尾逗号，
    目前，函数定义和调用时，都不允许有参数的尾逗号


