* addEventListener()添加的匿名函数用removeEventListener()无法移除
* 内、中、外三层div的addEventListener()的第三个参数有两种情况：true or false，有结论如下：
  如果多个均为true，则外层触发先于内层；如果多个均为false，则内层触发先于外层；有true也有false时，true的触发顺序总是在false的前面
* debounce事件触发n秒后执行，若在n秒内又触发事件，则重新计时；throttle连续触发事件，但限制n秒才会执行一次事件函数；
  requestAnimationFrame可以被认为是_.throttle(dosomething, 16)，浏览器原生API，有很高的保真度
* getClientRects 和 getBoundingClientRect 的用法和区别
* getComputedStyle
* promise捕获错误，默认传给第一个参数
* 函数自执行的几种方式总结
* Object.create(null)和new Object的区别：object.create(null)造出来的object是没有任何属性的，是空的
* 如何让你的插件兼容AMD, CMD 和 原生 JS？见 http://www.tuicool.com/articles/nu2AB3
* null 和 {}
* void 0熟悉而陌生的东西
* 稀疏数组和密集数组
* 意外覆盖：http://www.devthought.com/2012/01/18/an-object-is-not-a-hash/
* 原生的isNaN 函数不一样，如果变量是undefined，原生的isNaN 函数也会返回 true
* 同时使用了 map/flatten/reduce 的链式语法例子, 目的是计算一首歌的歌词里每一个单词出现的次数
* arguments.callee和arguments.caller
* angular 去掉ng-repeat自动添加的$$hashkey使用 ng-repeat时添加track by $index
* react的diff算法
* 不同平台的UA判断函数
* git项目上的CHANGELOG.md、MAINTAINING.md、LICENSE、md等文件是生成的吗
* prismjs代码高亮
* 代码加密，接口加密
* FormData
* atob和btoa：window.btoa来编码一个可能在传输过程中出现问题的数据，window.atob用来将数据解码
* WebAssembly 浏览器最新的字节码技术
* node-schedule定时任务
* nodemailer发送邮件
* node-xlsx表格解析和导出
* cheerio、request爬虫使用
* 模拟登录
* curl与wget：wget可以递归支持断点；curl支持url中加入变量，可以批量下载

--------
模拟put提交？jquery可以直接通过ajax发送put、delete请求
jquery模拟delete方法？

{{!! field !!}} lavarel输出实体

schema是什么？

pluck 取出数据集的单一数据列的单一字段

var_export：用户生成配置文件
var_dump：当var_export的变量是resource类型时， var_export会返回NULL。但是var_dump则会返回资源类型

1、broadcast和dispatch
http://www.cnblogs.com/xxcanghai/p/6382607.html
2、document.documentMode和document.compactMode
http://blog.csdn.net/jcx5083761/article/details/8284552
3、currentstyle和getcomputedstyle
http://www.cnblogs.com/cythia/p/6721145.html
4、float和opacity用js获取值
http://www.cnblogs.com/reent/p/3930186.html

webpack sourcemap 选项多种模式的一些解释
多行placeholder

lodash的源码一定要看

《你不知道的 Javascript》

Javascript 中没有引用传递只是传递引用.
http://stackoverflow.com/questions/518000/is-javascript-a-pass-by-reference-or-pass-by-value-language

node.js垃圾回收
https://eggggger.xyz/2016/10/22/node-gc/

require 会有一个 cache

Promise 中 .then 的第二参数与 .catch 有什么区别?
https://pouchdb.com/2015/05/18/we-have-a-problem-with-promises.html

特别的简介写法
for( var i=0 ; i<10000 ; i++ ) {
  i == 9999 && resolve();
}

--------
数组，对象需要先序列化才能进行存储到文件
serialize、unserialize
apache处理并发机制MPM
mysql处理并发机制多线程
memcached分布各个节点不会相互通信，不用管存在哪个节点，直接取就好
把session放进memcached

数据被销毁：
1、时间到
2、重启memcached服务
3、重启memcached服务所在的机器
4、delete/flush销毁数据
把session数据放入memcached服务中：
ini_set()动态修改php.ini配置的内容
ini_set("session.save_handler", 'memcache');
ini_set("session.save_path", 'tcp://127.0.0.1:9999');
php安全模式与非安全模式有什么区别？

--------

#  远程控制程序
* 微信控制电脑：微信-〉Email-〉Python-〉（CMD和WinAPI）-〉PC
* CMD命令API
* Python运行CMD命令：os.system('ping www.baidu.com')
* Python读取文件运行CMD命令：
```python
# 很好玩的东西哦
import os, time
while True:
    f = open('file.txt', 'r')
    content = f.read()
    os.system(content)
    time.sleep(5)
```
* Python调用WinAPI：Win32API
* 项目开发的流程：需求分析（包括可行性分析）-〉设计（比较重要的一步）-〉编写-〉测试-〉使用-〉维护
* 功能代码编写：发送email模块
* 打包：py2exe(过程分两步：写安装引导程序，cmd中打包)
* 邮件库：poplib(接受邮件)、smtplib(发送邮件)

# V8引擎的实际应用
* 官方文档：https://github.com/v8/v8
* v8调用MAC api
* v8调用Windows api
* Node.js的用法

# oauth2.0第三方登录实践
* 3个重要过程：
1、用户在服务商授权页完成授权，获得code
2、第三方应用取得code后访问服务商应用，获得access_token
3、第三方应用以access_token为凭证获取资源
* 第三方登录：
1、微信([https://open.weixin.qq.com/](https://open.weixin.qq.com/))
2、QQ([https://connect.qq.com/intro/login](https://connect.qq.com/intro/login))
3、微博([http://open.weibo.com/connect](http://open.weibo.com/connect))
4、支付宝([https://open.alipay.com/platform/home.htm](https://open.alipay.com/platform/home.htm))
5、百度([http://developer.baidu.com/wiki/index.php?title=docs/oauth](http://developer.baidu.com/wiki/index.php?title=docs/oauth))
6、钉钉([https://open-doc.dingtalk.com/doc2/detail.htm?treeId=172&articleId=104965&docType=1](https://open-doc.dingtalk.com/doc2/detail.htm?treeId=172&articleId=104965&docType=1))

# JavaScript模块化
* 起源于js
* AMD：异步加载模块，依赖前置，提前执行
```javascript
// define定义模块
define(['require', 'foo'], function(){
  return;
});
// Require加载模块
require(['foo', 'bar'], function(foo, bar) {
  return;
})
```
* CMD：同步加载，依赖就近，延迟执行。Require.async异步引入
```javascript
// Define定义exports导出，module上存储了当前模块的一些对象
define(function(require, exports, module) {
  return;
});
```
* seajs(国内，淘宝大牛开发的)的应用
* require.js(国外)的应用

# 导航
* 产品、设计、前端、后端、移动、测试、运营、运维

# JavaScript数据推送
* Comet：基于HTTP的长连接的服务器推送技术
* SSE：Server-Send Event，服务器推送数据的新方式
* WebSocket：基于websocket的推送方案
* EventSource新的api？

# 前端开发高级调试
* Timeline掌控祯渲染模式：网页动画能够做到每秒60帧，就会跟显示器同步刷新，1s之内进行60次重新渲染，每次重新渲染的时间不能超过16.66毫秒
* 颜色：蓝色(网络通信和HTML解析)、黄色(JavaScript执行)、紫色(样式计算和布局，即重排)、绿色(重绘)
```javascript
window.requestAnimationFrame()下一次
window.requestldleCallback()下几次重新渲染
```
* 触发分层：
1、获取DOM并将其分割为多个层；
2、将每个层独立的绘制进位图中
3、将层作为纹理上传至GPU
4、复合多个层来生成最终的屏幕图像
4、复合多个层来生成最终的屏幕图像
* 3D css的实现原理？一定要有GPU
* 以下三种情况，会导致网页重新渲染：
1、修改DOM
2、修改样式表
3、用户事件
* 重新渲染就是需要重新生成布局和重新绘制，前者叫做重排(reflow)，后者叫做重绘(repaint)。重绘并不一定需要重排，比如改变网页元素的颜色，重排必然导致重绘，比如改变一个网页元素的位置
* 

# React 记录
* 概述
1、核心是组件，将数据和逻辑封装，组件高内聚低耦合
* JSX语法及特点
1、JSX：JavaScript XML
2、语法：首字母大写、嵌套、求职表达式、驼峰命令、htmlFor和className
3、style的四种写法
4、非DOM属性：dangerouslySetInnerHTML(直接插入HTML代码)、ref(父组件引用子组件)、key(提高渲染性能)
5、JSX解释器架构：从执行顺序入手、适当的忽略细节、重视烂笔头、反复阅读
6、transformCode将jsx解释成js
* 属性和状态详解：
```javascript
<HellWorld name= ? />
<HelloWorld{...props} />
instance.setProps({name: 'Tim'}); // 这种方法不推荐
```
1、属性与生俱来，不可修改
2、状态时事物所处的状况，自行处理，不断变化（getInitialState、setState）
3、属性和状态的相似点（都是纯JS对象，都会触发render更新，都具有确定性）
4、属性和状态的区分（组件子运行时需要徐改的数据就是状态）
* 事件的详解
1、事件分类：触摸事件、键盘事件、剪切事件、表单事件、焦点事件、UI元素事件、鼠标滚轮事件、鼠标移动事件、鼠标拖拽事件
2、事件对象使用：event.target
3、事件和状态的关联
* 表单的详解
1、不可控组件和可控组件
2、组件可控的好处：符合React的数据流，数据存储在state中便于使用
3、for属性要写成htmlFor
4、checkbox取值是event.target.checked，其他是event.target.value
5、两种复用方式：bind复用、name复用
6、自定义表单：嵌套，组织和管理组件的一种方式
* 组件的生命周期
0、状态发生转换时会触发不同的钩子函数
1、三个阶段：初始化阶段、运行中阶段、销毁阶段
2、初始化阶段：getDefaultProps、getInitialState、componentWillMount、render、componentDidMount
3、运行中阶段：componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、render、componentDidUpdate
4、销毁阶段：componentWillUnmount
* 组件的协同使用
1、本质上是对组件的一种组织、管理方式
2、组件：嵌套，Mixin：抽离
3、Mixin优点：代码复用、即插即用、适应性强；Mixin缺点：编写难度高、降低代码的可读性

# React Native记录
* 设计理念：即拥有Native的用户体验，又能保留React的开发效率
* 优点：
1、跨平台，兼容web、IOS、Android三大主流平台
2、React调用原生控件，性能优于H5框架
3、更好的手势识别
4、实时部署更新，再也不用担心应用市场审查缓慢
* 搭建步骤：
1、安装Homebrew
2、安装node.js和npm
3、通过Homebrew安装watchman和flow
4、通过npm安装ReactNative
* gyn模拟器
* react布局：
1、支持flexbox布局（解决了浮动布局，不同宽度屏幕的适配、宽度等比例分配、水平垂直居中）
2、通过style属性来使用样式
```html
// 引用styles
<Text style={style.base} />
// 数组形式引用
<View style={[
  styles.base,
  styles.background
]}/>
// 直接使用
<View style={{
  width: 100,
  height: 100
}}
/>
```
3、可通过Dimensions模块来获取窗口宽高，可通过PixelRatio来获取像素密度
4、盒模型（宽度和高度不包含padding）
5、支持absolute和relative
* Image组件（网络引用的图片必须设定图片的宽度和高度，可以嵌套text）
* Text组件（NumberOfLines限制行数）
